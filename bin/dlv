#!/usr/bin/env elixir

defmodule YTDL do
  def start(parent, input) do
    #TODO: write cache: echo "$@" > ".dlv/$(md5 <<< $@)"
    Task.start(fn -> YTDL.dl(input, parent) end)
  end
  def dl(input, parent) do
    input = "--newline --no-warnings #{input}"
    input = if File.exists?("youtube-dl.config") do
      "--config-location youtube-dl.config #{input}"
    else
      input
    end
    filename = get_filename(input)
    IO.puts "FILE: #{filename}"
    Port.open({:spawn, "youtube-dl #{input}"},
              [:binary, :exit_status, :stderr_to_stdout])
    |> YTDL.receive(filename, parent)
  end
  def get_filename(input) do
    case System.cmd("youtube-dl", String.split("--get-filename #{input}")) do
      {value, 0} -> value
      {error, ecode} -> IO.puts("error #{ecode}: #{error}"); raise error
      idk -> IO.inspect idk
    end
  end
  def receive(ytdl, filename, parent) do
    receive do
      {^ytdl, {:data, line}} ->
        YTDL.progress(filename, line)
        YTDL.receive(ytdl, filename, parent)
      {^ytdl, {:exit_status, ecode}} ->
        IO.puts "EXIT#: #{ecode}"
        YTDL.exit(parent, filename, ecode)
      {:EXIT, ^ytdl, reason} ->
        IO.puts("YTDL EXIT: #{reason}")
        YTDL.exit(parent, filename, reason)
    end
  end
  def exit(parent, filename, ecode_or_reason) do
    #TODO: if ecode_or_reason ~= ok do clear cache/locks
    #TODO: rename 's/(^(\[.*?\])+ *|\.mp4-)//g' filename
    send parent, {:ytdl, :exit}
  end
  def progress(filename, line) do
    IO.puts("<#{String.trim(filename)}>:\n#{Regex.replace(~r<\[download\]\s+>, line, "")}")
  end
end

defmodule PRLL do
  #TODO: take a list of work to start doing
  def start() do
    Task.start(fn -> loop(%{queue: [], max: 8, procs: 0}) end)
  end
  def loop(m) do
    %{queue: queue, max: max, procs: procs} = IO.inspect m
    if procs < max and List.first(queue) do
      {next, queue_} = List.pop_at(queue, -1)
      YTDL.start(self(), next)
      loop(m |> Map.put(:queue, queue_) |> Map.update!(:procs, &(&1+1)))
    else
      receive do
        {:line, input} -> loop(Map.update! m, :queue, &([input | &1]))
        {:ytdl, :exit} -> loop(Map.update! m, :procs, &(&1-1))
        other -> IO.inspect other; loop(m)
      end
    end
  end
end

defmodule DLV do
  def read_stdin(prll, :eof) do
    IO.puts "END OF FILE, DLV DONE"
    #TODO: send :eof to all PRLL procs
    #TODO: EOF: check no *part & no ~/.dlv/*
  end
  def read_stdin(prll, {:error, reason}) do
    IO.puts "ERROR: #{reason}"
  end
  def read_stdin(prll, input) do
    if String.trim(input) != "" do
      send prll, {:line, input}
    end
    DLV.read_stdin(prll)
  end
  def read_stdin(prll) do
    DLV.read_stdin(prll, IO.read(:stdio, :line))
  end

  def main(_) do
    IO.inspect(Path.wildcard(Path.expand("~")<>"/.dlv/*"))
    #TODO: cache read & send to PRLL.start
    {:ok, prll} = PRLL.start()
    DLV.read_stdin(prll)
  end
end

DLV.main(System.argv())
