#!/usr/bin/env python3
import argparse
import multiprocessing as mlt
import os
from pprint import pprint
import signal
import subprocess
import sys

def shut_down(pool, pids):
    for pid in list(map(lambda i: i.pid, pool._pool)) + pids:
        try: os.kill(int(pid), signal.SIGTERM)
        except: pass

parser = argparse.ArgumentParser(description='Optional app description')
parser.add_argument('command', help='Command to exec in parallel')
group = parser.add_mutually_exclusive_group()
group.add_argument('-j', '--jobs', type=int,
        help='Number of jobs to execute in parallel')
group.add_argument('-J', '--cpu-jobs', type=int,
        default=2, help='Number of jobs per cpu core')
args = parser.parse_args()
cmd = args.command
jobs = args.jobs or args.cpu_jobs

def run_sh(line):
    return subprocess.Popen(cmd + " " + line, shell=True).pid

original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
pool = mlt.Pool(processes=jobs)
signal.signal(signal.SIGINT, original_sigint_handler)
pids = []
try:
    for pid in pool.imap(run_sh, sys.stdin):
        pids.append(pid)
except KeyboardInterrupt:
    try:
        pool.terminate()
        shut_down(pool, pids)
    except KeyboardInterrupt:
        pool.terminate()
